---
layout: post
title: 使用单元测试来帮助前端开发
date: 2020-02-27 22:35:12 +0800
author: yitimo
categories: front end
tags: ["front end", "unit test", "jest"]
keywords:
- front end,
- unit test,
- jest,
description: use unit test to help front end develop.
---

## 单元测试做了什么

从单元测试字面意思可以想到，这是对项目内的某个最小单元(类的方法、工具函数、条件语句)进行的测试。
对于开发人员来说，项目开发过程一般只进行冒烟测试，且只是以代码正确执行为目的。更全面的业务、流程测试要让专门的测试工程师来完成。成功的单元测试还能减轻测试人员的工作，尽量避免让他们来帮我们找空指针、死循环、页面白屏之类的代码错误。

而像jest、mocha等这些测试框架就是通过提供一个强大的测试环境，支持只执行某个被 ``import`` 进来的模块，并能尽可能的模拟所有测试用例执行时不需要关心只需要执行结果的流程和副作用。

最终能做到的就是，单元测试用例里一个模块是如何执行的，正式上线时这个模块代码就是如何执行的，这就能避免很多代码执行错误。同时凭借测试框架附带的其他强大能力，我们还能提前得知自己代码的逻辑复杂度、测试覆盖率等信息。

举个例子，我们有一个 ``getBillAction`` 函数用于获取在界面上展示的账单，做了这么一些事情:

1. 从 state、getters 中取出一些数据，拼装成请求参数
2. 使用拼装好的参数请求后端接口
3. 处理接口返回的结果，提取需要的字段更新到 state

如果我们想要真实复现这个行为来进行测试，假设我们已经开发完成了商品列表页和购物车页面直接从账单页开始测试流程，那我们需要做这么一些事情:

1. 启动项目并保证前置代码执行正确，比如用户登录凭证等一些动态数据
2. 将真实或模拟的数据同步到 state 中
3. 等页面加载完成后开始执行这个拉取账单的action
    1. 从 state、getters 中取出一些数据，拼装成请求参数
    2. 使用拼装好的参数请求后端接口
    3. 处理接口返回的结果，提取需要的字段更新到 state
4. 认为action已经执行完成后
    1. 检查开发者工具中的请求是否成功
    2. 界面上的展示是不是已经基于最新请求到的数据了

这里面有很多步骤是测试 ``拉取账单`` 这个单一行为之外的事情，这些步骤出现任何问题，都会干扰我们对我们的核心目的的测试，可能导致测试不准确，或者找到别的问题导致分心和混乱。

而凭借单元测试，我们对这个action的测试可以做这么一些事情:

1. 模拟一个 state, 我们可以造出正确的、不同情况的、故意出错的 state 用于全面测试
2. 模拟网络请求, 我们可以造出正确的、不同情况的、故意出错的响应结果用于检查后续处理流程
3. 在单元测试环境中执行这个action
    1. 从模拟的 state、getters 中取出一些数据，拼装成请求参数
    2. 使用模拟返回的结果，提取需要的字段更新到 state
4. 在用例中进行检查
    1. 最终 state 是否设置正确
    2. 覆盖率是否达到 100%, 或者有逻辑分支没考虑到?

测试这个action时我们模拟了发起请求，如果我们还想测试请求是否正确执行，比如是否正确使用了http客户端，那我们应该在另一个单元测试中专门测试这个api请求，因为这已经属于另一个单元了。

## 常见场景下怎么做单元测试

接下来基于jest介绍怎么配置和执行一些常用的单元测试。

现在一个前端项目源码可能由这些部分组成:

- js模块 主要测试的内容，jest天然支持，不过对于es6及以上的语法，需要配置 ``babel-jest``
- ts模块 主要的测试内容，需要配置 ``ts-jest``，以及在 ``tsconfig.json`` 的 ``types`` 中增加 ``jest``
- css样式和文件资源 这些模块更适合通过肉眼和开发者工具进行视觉对稿, ``jest`` 可以直接模拟跳过这些内容
- 界面组件标签 对于原生DOM, jest 天然支持，可以检查其节点和值。对于基于前端框架的组件，各框架本身都提供了自己的测试方式，用于在测试环境中渲染组件节点

### 同步模块的测试

一个同步的测试代码可能是这样的:

``` js
import 模块 from 'path/to/模块'

describe('这个单元测试的名字', () => {
    it('一个测试用例的名字', () => {
        // 直接匹配
        expect(需要验证的值).toEqual(需要匹配的值)
        // 匹配列表中的对象
        expect(需要验证的列表).toEqual(expect.arrayContaining([
            expect.objectContaining({
                列表中包含的object的某个key: value,
            })
        ]))
        // 匹配抛出错误
        expect(() => {
            执行应该抛出错误的逻辑
        }).toThrow()
    })
})
```

其中 expect 提供了非常多用于检查需要的值的方法，涵盖了常量、object、array等。详细可以直接参考[官方文档](https://jestjs.io/docs/en/using-matchers)。

### 异步模块的测试

对于异步模块你可能还需要在jest的初始化脚本中引入 ``babel-polyfill``, 配置好后即可正常进行 ``async/await`` 等异步语法测试:

``` js
describe('这个单元测试的名字', () => {
    it('一个测试用例的名字', async () => {
        const res = await 执行模块
        expect(res).toEqual(expect.arrayContaining([
            expect.objectContaining({
                列表中包含的object的某个key: value,
            })
        ]))
    })
})
```

### 模拟行为

**模拟样式和文件**

**模拟内部函数执行**

**模拟浏览器对象**

## 测试目的

笔者在《重构》书中多次被安利单元测试是如何帮助提升开发和最终代码质量的，
- 保证代码可靠性 让需要上线验证的全流程能提前有个底
- 贴近真实业务、交互编写用例 覆盖率不是最重要
- 帮助代码解耦 逻辑清晰 减少副作用
