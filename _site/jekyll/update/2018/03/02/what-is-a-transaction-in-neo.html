<!DOCTYPE html>
<html>
<head>
    <title>个人理解NEO中的合约交易 | yitimo的个人博客</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="HandheldFriendly" content="True" />
    <link rel="shortcut icon" href="/assets/images/favicon.ico" type="image/png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="/assets/css/global.min.css" />
    <link rel="stylesheet" type="text/css" href="/assets/css/post.css" />
    <!-- Begin Jekyll SEO tag v2.4.0 -->
<meta name="generator" content="Jekyll v3.7.2" />
<meta property="og:title" content="再見二丁目" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="yitimo的个人博客" />
<meta property="og:description" content="yitimo的个人博客" />
<link rel="canonical" href="https://blog.yitimo.com" />
<meta property="og:url" content="https://blog.yitimo.com" />
<meta property="og:site_name" content="再見二丁目" />
<script type="application/ld+json">
{"name":"再見二丁目","description":"yitimo的个人博客","@type":"WebSite","url":"https://blog.yitimo.com","headline":"再見二丁目","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<!-- Bing -->
<meta name="msvalidate.01" content="C6A533BFA9ED34F59CE76F9AC19623EF" />
<!-- Baidu -->
<meta name="baidu-site-verification" content="VWCN98I3kC" />
<!-- Sougou -->
<meta name="sogou_site_verification" content="7e6MA7i4va"/>
<!-- 360 -->
<meta name="360-site-verification" content="cdabf9283d84ba985379081ab8882306" />
<!-- google -->
<meta name="google-site-verification" content="yT-0lXiM2x-GWfMubV7vqohZtKCEVJqyMaj_LS-45J0" />
<script>
    // baidu统计
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?decb433e7fc3d68b16da80cdd59ee827";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    // baidu 站长
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

</head>
<body>
    <img src="/assets/images/background.jpg" id="background" />
    <div id="background-mask"></div>
    <div class="article">
        <h1>个人理解NEO中的合约交易</h1>
        <div class="post-date">by <span>yitimo</span> at <span> 2 March 2018</span></div>
        <p>本文将使用一个简单的web客户端，配合<code class="highlighter-rouge">neon-js</code>完成多系列交易（transaction）操作，说白也就是手动实现两种交易类型——InvocationTransaction和ContractTransaction。以此来帮助理解NEO中的用户、智能合约以及两者的交互。</p>

<p>本文将完成以下操作：</p>

<ol>
  <li>用户给用户转账</li>
  <li>用户给普通<code class="highlighter-rouge">NEP-5智能合约</code>转账，并调用<code class="highlighter-rouge">mintTokens</code>方法取出代币，也就是参与一次ico操作</li>
  <li>简单智能合约给用户转账(深坑)</li>
</ol>

<p>本文准备的项目为一个简单的web项目，基于<code class="highlighter-rouge">angular</code>，各种钱包操作通过调用<code class="highlighter-rouge">neon-js</code>实现。(实际上<a href="https://github.com/CityOfZion">CityOfZion</a>的<code class="highlighter-rouge">neon-wallet</code>轻钱包就是这么个东西)</p>

<h2 id="neon-js-提供的接口">neon-js 提供的接口</h2>

<p>浏览<code class="highlighter-rouge">neon-js</code>源码大致能找到其提供的几类接口：</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 这算是个别名，用它能实现很多底层操作</span>
<span class="k">import</span> <span class="nx">Neon</span> <span class="k">from</span> <span class="s1">'@cityofzion/neon-js'</span><span class="p">;</span>
<span class="c1">// tx包含了交易相关接口</span>
<span class="c1">// wallet包含了钱包相关接口</span>
<span class="c1">// api包含了一些通用接口</span>
<span class="c1">// rpc包含了有关rpc接口的接口(rpc接口为远程的neo-cli项目提供的接口)</span>
<span class="k">import</span> <span class="p">{</span><span class="nx">tx</span><span class="p">,</span> <span class="nx">wallet</span><span class="p">,</span> <span class="nx">api</span><span class="p">,</span> <span class="nx">rpc</span><span class="p">}</span> <span class="k">from</span> <span class="s1">'@cityofzion/neon-js'</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="transaction类">Transaction类</h2>

<p><code class="highlighter-rouge">Transaction</code>类可以说是<code class="highlighter-rouge">neon-js</code>中最核心的一个类了，正如<code class="highlighter-rouge">sendrawtransaction</code>接口是<code class="highlighter-rouge">/rpc</code>接口中最有用的接口，这个<code class="highlighter-rouge">Transaction</code>类实例化的对象就是最终用来请求这个rpc接口进而产生新区快的东西，没错，就是<code class="highlighter-rouge">utxo</code>。</p>

<p><code class="highlighter-rouge">Transaction</code>中有两个静态方法可以用来很方便的创建一个utxo，分别是<code class="highlighter-rouge">createInvocationTx</code>和<code class="highlighter-rouge">createContractTx</code>，只看字面也能知道，前者是用来创建一个带有合约调用的交易，后者则只有交易没有合约调用。</p>

<p>显然，接下来要完成的三个操作中，用户给用户转账就调用<code class="highlighter-rouge">createContractTx</code>来创建utxo，用户参与ico就调用<code class="highlighter-rouge">createInvocationTx</code>，至于鉴权合约，比较特殊，会单独讲，再次强调这是个深坑。</p>

<h2 id="完成用户给用户转账">完成用户给用户转账</h2>

<p><em>题外话：用angular项目作为轻钱包客户端有一个天然优势，就是支持javascript，强大的代码提示节省了不少精力。</em></p>

<p>创建一个转账交易，然后签名并广播这个交易的代码如下：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 创建utxo</span>
<span class="kd">let</span> <span class="nx">utxo</span> <span class="o">=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Transaction</span><span class="p">.</span><span class="nx">createContractTx</span><span class="p">(</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">balance</span><span class="p">,</span> <span class="c1">// 谁转账填谁的余额</span>
    <span class="nx">api</span><span class="p">.</span><span class="nx">makeIntent</span><span class="p">({</span><span class="na">NEO</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="s1">'目标地址'</span><span class="p">),</span> <span class="c1">// 转到谁的地址多少钱</span>
    <span class="kc">null</span> <span class="c1">// 忽略这个参数</span>
<span class="p">);</span>
<span class="c1">// 对utxo签名 花谁的钱就要签谁的名</span>
<span class="nx">utxo</span> <span class="o">=</span> <span class="p">(</span><span class="nx">utxo</span> <span class="k">as</span> <span class="nx">any</span><span class="p">).</span><span class="nx">sign</span><span class="p">(</span><span class="s1">'这里填转账人的私钥'</span><span class="p">);</span>
<span class="c1">// 发送这个utxo</span>
<span class="nx">rpc</span><span class="p">.</span><span class="nx">Query</span><span class="p">.</span><span class="nx">sendRawTransaction</span><span class="p">(</span><span class="nx">utxo</span><span class="p">).</span><span class="nx">execute</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">rpcUrl</span><span class="p">).</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">res</span><span class="p">);</span>
<span class="p">}).</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>其中有两个参数需要额外获取，也就是<code class="highlighter-rouge">this.balance</code>和<code class="highlighter-rouge">this.rpcUrl</code>，在ngOninit()中先获取到：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">ngOnInit</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 传入地址获取改地址的余额，用于后续计算交易的输入</span>
    <span class="nx">api</span><span class="p">.</span><span class="nx">neonDB</span><span class="p">.</span><span class="nx">getBalance</span><span class="p">(</span><span class="s1">'TestNet'</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">owner</span><span class="p">).</span><span class="nx">then</span><span class="p">((</span><span class="nx">res</span><span class="p">:</span> <span class="nx">wallet</span><span class="p">.</span><span class="nx">Balance</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">balance</span> <span class="o">=</span> <span class="nx">res</span><span class="p">;</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">res</span><span class="p">.</span><span class="nx">assets</span><span class="p">[</span><span class="s1">'NEO'</span><span class="p">]));</span>
    <span class="p">});</span>
    <span class="c1">// 获取测试网的rpc接口地址</span>
    <span class="nx">api</span><span class="p">.</span><span class="nx">neonDB</span><span class="p">.</span><span class="nx">getRPCEndpoint</span><span class="p">(</span><span class="s1">'TestNet'</span><span class="p">).</span><span class="nx">then</span><span class="p">((</span><span class="nx">url</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">rpcUrl</span> <span class="o">=</span> <span class="nx">url</span><span class="p">;</span>
    <span class="p">}).</span><span class="k">catch</span><span class="p">((</span><span class="nx">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">);</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>执行前面一段代码顺利的话转账就完成了，前提是余额中要有足够的NEO。此过程值得注意的是签名前后的交易有何不同：</p>

<p><img src="/assets/images/201803/sign-result.png" alt="签名前后的交易" /></p>

<p>可以看到签名后<code class="highlighter-rouge">scripts</code>字段多了一项，这就是用发送者的私钥添加上的见证人脚本。实际上本次交易中涉及到多少方的input就需要逐个加上其见证人脚本。</p>

<p>除此之外我们还可以看看一个utxo究竟长啥样，看到包含了type、inputs、outputs、scripts等字段。其中<code class="highlighter-rouge">type</code>为128指示这是个转账交易，<code class="highlighter-rouge">inputs</code>包含了本次交易的输入的utxo，<code class="highlighter-rouge">outputs</code>包含了本次交易都有什么资产(assetId)转到了哪里(scriptHash)多少钱(value)，<code class="highlighter-rouge">scripts</code>也就是签名了。</p>

<h2 id="合约调用交易">合约调用交易</h2>

<p>至于合约调用交易参数略有不同：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">newTx</span> <span class="o">=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Transaction</span><span class="p">.</span><span class="nx">createInvocationTx</span><span class="p">(</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">balance</span><span class="p">,</span> <span class="c1">// 用户的余额</span>
    <span class="nx">api</span><span class="p">.</span><span class="nx">makeIntent</span><span class="p">({</span><span class="na">NEO</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span> <span class="nx">wallet</span><span class="p">.</span><span class="nx">getAddressFromScriptHash</span><span class="p">(</span><span class="s1">'代币的脚本哈希去掉最前面的0x'</span><span class="p">)),</span> <span class="c1">// 转1NEO到代币的地址</span>
    <span class="p">{</span><span class="na">operation</span><span class="p">:</span> <span class="s1">'mintTokens'</span><span class="p">,</span> <span class="na">scriptHash</span><span class="p">:</span> <span class="s1">'合约的脚本哈希去掉最前面的0x'</span><span class="p">},</span> <span class="c1">// 合约mintTokens以获取代币</span>
    <span class="mi">0</span><span class="p">,</span> <span class="kc">null</span> <span class="c1">// gas消耗以及重写参数 直接忽略</span>
<span class="p">);</span>
</code></pre></div></div>

<p>只要调用的智能合约本身没问题，一切都会很顺利，顺便看看这种情况下的utxo长什么样：</p>

<p><img src="/assets/images/201803/invoke-transaction.png" alt="合约调用交易" /></p>

<p>其中别的同意都一样，输入是余额中取出来的utxo，输出是转1NEO到合约地址，以剩下的的钱找零回自己的地址，同时还有自己的签名。</p>

<p>不一样之处就是<code class="highlighter-rouge">type</code>变为了209，并且多了一个<code class="highlighter-rouge">script</code>字段，包含了本次合约调用参数的hash。</p>

<p>也就是说，这个交易，在转账的同时调用了一下mintTokens方法。</p>

<h2 id="合约给地址转账">合约给地址转账</h2>

<p>首先明白只要转账就必须要签名，跟购物刷卡一样。</p>

<p>然后明白签名就要签自己的名，还是跟刷银行卡一样。</p>

<p>接下来要明白其实普通用户账户也是个智能合约，也有自己的脚本哈希，区别是用户账户还有个私钥，而智能合约账户只有自己的脚本代码。而就是说，智能合约转账会触发其中的鉴权合约逻辑，而用户转账其实也会触发自己的鉴权合约逻辑，必须有自己的签名才会通过。</p>

<p>那么现在问题来了，智能合约想要给用户转账的话，也必须要签名，而且得签自己的名，用户签名用的是自己的私钥，那么智能合约怎么签名？</p>

<p>答案是用智能合约的脚本，也就是<code class="highlighter-rouge">neo-gui</code>中加载avm文件后读出来的那一长串字符。</p>

<p>现在要转过来说说一个智能合约是如何工作的(非源码层面，仅关注其代码逻辑)，先看下面这段只能合约代码：</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">public</span> <span class="kd">class</span> <span class="nx">YitimoA</span><span class="p">:</span> <span class="nx">SmartContract</span>
<span class="p">{</span>
    <span class="kr">public</span> <span class="kr">static</span> <span class="nx">readonly</span> <span class="kr">byte</span><span class="p">[]</span> <span class="nx">Owner</span> <span class="o">=</span> <span class="s2">"AaHEnwbT15CYHaWYyfbmAxWWaGT3Zzvk3B"</span><span class="p">.</span><span class="nx">ToScriptHash</span><span class="p">();</span>

    <span class="kr">public</span> <span class="kr">static</span> <span class="nb">Object</span> <span class="nx">Main</span><span class="p">(</span><span class="nx">string</span> <span class="nx">operation</span><span class="p">,</span> <span class="nx">params</span> <span class="nx">object</span><span class="p">[]</span> <span class="nx">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">Runtime</span><span class="p">.</span><span class="nx">Trigger</span> <span class="o">==</span> <span class="nx">TriggerType</span><span class="p">.</span><span class="nx">Verification</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">Runtime</span><span class="p">.</span><span class="nx">CheckWitness</span><span class="p">(</span><span class="nx">Owner</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">// 这里面不要PutStorage但是可以Get</span>
            <span class="c1">// 检查是否匹配上一个存入的数据</span>
            <span class="kd">var</span> <span class="nx">lastcall</span> <span class="o">=</span> <span class="nx">Storage</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">Storage</span><span class="p">.</span><span class="nx">CurrentContext</span><span class="p">,</span> <span class="s2">"lastcall"</span><span class="p">).</span><span class="nx">AsString</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">operation</span> <span class="o">==</span> <span class="nx">lastcall</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">Runtime</span><span class="p">.</span><span class="nx">Trigger</span> <span class="o">==</span> <span class="nx">TriggerType</span><span class="p">.</span><span class="nx">Application</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="nx">operation</span> <span class="o">==</span> <span class="s2">"call"</span><span class="p">)</span> <span class="c1">// 不管谁来执行这个都爆炸 连false都不返回</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">Runtime</span><span class="p">.</span><span class="nx">CheckWitness</span><span class="p">(</span><span class="nx">Owner</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="nx">Storage</span><span class="p">.</span><span class="nx">Put</span><span class="p">(</span><span class="nx">Storage</span><span class="p">.</span><span class="nx">CurrentContext</span><span class="p">,</span> <span class="s2">"lastcall"</span><span class="p">,</span> <span class="p">(</span><span class="kr">byte</span><span class="p">[])</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
                    <span class="k">return</span> <span class="s2">"done"</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">return</span> <span class="s2">"notyitimo"</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">operation</span> <span class="o">==</span> <span class="s2">"goahead"</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nx">Storage</span><span class="p">.</span><span class="nx">Put</span><span class="p">(</span><span class="nx">Storage</span><span class="p">.</span><span class="nx">CurrentContext</span><span class="p">,</span> <span class="s2">"lastcall"</span><span class="p">,</span> <span class="p">(</span><span class="kr">byte</span><span class="p">[])</span><span class="nx">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
                <span class="k">return</span> <span class="s2">"done"</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">operation</span> <span class="o">==</span> <span class="s2">"check"</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="nx">Storage</span><span class="p">.</span><span class="nx">Get</span><span class="p">(</span><span class="nx">Storage</span><span class="p">.</span><span class="nx">CurrentContext</span><span class="p">,</span> <span class="s2">"lastcall"</span><span class="p">).</span><span class="nx">AsString</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="s2">"unknownmethod"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>其中<code class="highlighter-rouge">if (Runtime.Trigger == TriggerType.Verification)</code>用来区分这是个鉴权合约还是个调用合约，也就是说，是从合约中转钱出去呢，还是只是调用合约的方法。用流程图来表示这段代码如下：</p>

<p><img src="/assets/images/201803/code-flow.png" alt="四种执行情况" /></p>

<p>重难点如下：</p>

<ul>
  <li>从谁转钱出去就触发谁的鉴权合约</li>
  <li>鉴权合约也可以传入参数，传入的参数与合约调用时传入的参数不同，是放在scripts字段中的，也就是是见证人脚本的一部分。而合约方法调用的参数则是放在script字段中。也就是说是两条完全不同的流程，虽然代码在一起。</li>
  <li>应用合约逻辑中有CheckWitness可以检查调用者地址，但是鉴权合约中的CheckWitness是检查合约本身地址的(类比普通用户的鉴权合约，也是鉴的用户自己)。也就是说，见证人是管理员的情况下从合约中取钱，一样无法通过鉴权合约中的CheckWitness，因为只有合约自己通的过。</li>
</ul>

<p>理解了这一些，就应该能明白上面这段合约代码是干什么的，也就是：</p>

<ul>
  <li>通过调用合约设置一个密码，从合约中转钱出来时则必须匹配这个密码。</li>
  <li>只有管理员能调用call方法来设置密码</li>
  <li>所有人都能调用goahead方法来设置密码</li>
</ul>

<p>本文应该还能回答一个问题，一个笔者找遍全世界找不到答案的问题——参与ico用NEO换代币这个操作可以说是很简单了，但是ico进去的NEO到底怎么取出来呢？</p>

        <div class="flex" style="margin: 30px 0;">
            <div class="flex-1">
                <a class="another-post" href="/jekyll/update/2018/02/26/how-to-connect-neon-js-to-private-net.html">上一篇： 使用 neon-wallet-db + neon-js + NEO-cli /rpc 搭建轻钱包服务端</a>
                </div>
            <a class="back" href="/">回到首页</a>
        </div>
    </div>
    <div class="footer flex" style="overflow-x: auto;">
    <div class="flex-1">
        yitimo的其他站点: <br /><br />
        <a target="blank" href="https://github.com/yitimo">GitHub</a>
        <a target="blank" href="https://www.yitimo.com">个人网站</a>
    </div>
    <div class="flex-1">
        站点同时部署在以下地址: <br /><br />
        <a href="https://blog.yitimo.com">blog.yitimo.com</a>
        <a href="https://yitiblog.netlify.com">yitiblog.netlify.com</a>
        <a href="https://yitimo.github.io">yitimo.github.io</a>
    </div>
    <div class="flex-1">
        联系我: <br /><br />
        <a href="javascript:void(0)">admin@yitimo.com</a>
        <a href="javascript:void(0)">yitimohu@gmail.com</a>
    </div>
</div>
    <script src="/assets/js/init.js"></script>
</body>
</html>
