<!DOCTYPE html>
<html>
<head>
    <title>自己搭建ngrok服务器代理本地服务 | yitimo的个人博客</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="HandheldFriendly" content="True" />
    <link rel="shortcut icon" href="/assets/images/favicon.ico" type="image/png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="/assets/style.css">
    <!-- Begin Jekyll SEO tag v2.4.0 -->
<meta name="generator" content="Jekyll v3.7.2" />
<meta property="og:title" content="再見二丁目" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="yitimo的个人博客" />
<meta property="og:description" content="yitimo的个人博客" />
<link rel="canonical" href="https://blog.yitimo.com" />
<meta property="og:url" content="https://blog.yitimo.com" />
<meta property="og:site_name" content="再見二丁目" />
<script type="application/ld+json">
{"name":"再見二丁目","description":"yitimo的个人博客","@type":"WebSite","url":"https://blog.yitimo.com","headline":"再見二丁目","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<!-- Bing -->
<meta name="msvalidate.01" content="C6A533BFA9ED34F59CE76F9AC19623EF" />
<!-- Baidu -->
<meta name="baidu-site-verification" content="VWCN98I3kC" />
<!-- Sougou -->
<meta name="sogou_site_verification" content="7e6MA7i4va"/>
<!-- 360 -->
<meta name="360-site-verification" content="cdabf9283d84ba985379081ab8882306" />
<!-- google -->
<meta name="google-site-verification" content="yT-0lXiM2x-GWfMubV7vqohZtKCEVJqyMaj_LS-45J0" />

</head>
<body>
    <h1 style="display: none;">再見二丁目 | yitimo的个人博客</h1>
    <div class="yitiblog">
        <header class="yitiblog-header-container">
            <div class="yitiblog-header flex">
                <img src="/assets/images/yitimo.jpg" class="avatar" />
<b class="title">再见二丁目</b>

            </div>
        </header>
        <section class="yitiblog-content article">
            <h1>自己搭建ngrok服务器代理本地服务</h1>
            <h2 id="ngrok做了什么">ngrok做了什么</h2>

<p>正常的网络拓扑下，一般通过 <code class="highlighter-rouge">255.255.255.0</code> 掩码区分不同网段，即IP的前三段都相同视为同一网段，若想要让两个网段通信，则需要通过路由器来完成，通过在路由器中配置路由表，使两个不同网段的IP建立映射关系。</p>

<p>一般我们请求某个服务器地址时，显然本地局域网地址和远程服务器地址不在同一网段，我们是本地通过连接到本地网关，然后连接至互联网，然后连接至远程服务器。</p>

<p>但是反过来就不行了，想象一下远程服务器该如何请求到一个本地的局域网地址？</p>

<p>答案是NAT技术。</p>

<p>个人版的NAT技术的粗暴理解：类比一下本地请求远程时，客户端是如何接收到远程服务器响应的。对于远程服务器来说，其实只知道有另一个外网地址请求了自己，并给了他响应，这个外网地址即本地网关的外网地址，再由本地网关将这个来自服务器的响应精准的返回给本地地址。即本地网关把一个来自外网服务器的响应转发给了一个本地地址。</p>

<p>所以有哪些简单的方法可以做到：在本地运行一个站点，请求一个外网地址访问到这个站点？</p>

<ol>
  <li>直接给本地分配一个外网IP</li>
  <li>通过一个连接至外网的路由器进行NAT</li>
  <li>通过ngrok</li>
</ol>

<p>ngrok的内部做法和NAT不一样(目测其建立了一个C/S连接来实时监听并转发请求，而NAT只需一张映射表被动的转发请求)，但做的事情类似，远程服务器请求的是我们拥有外网地址的网关(运行了ngrok server的个人服务器)，然后由 ngrock server 来映射至建立好连接的本地 ngrok client，并根据 ngrok client 配置好的规则转发至特定端口。总结：整个ngrok(包括运行在本地的client)都属于负责转发请求的网关，这整个过程成为内网穿透。</p>

<h2 id="ngrok能做什么">ngrok能做什么</h2>

<ul>
  <li>本地调试微信授权</li>
  <li>本地调试 github hook</li>
  <li>任何需要接收外网回调的调试场景</li>
</ul>

<h2 id="使用ngrok需要自己准备什么">使用ngrok需要自己准备什么</h2>

<ul>
  <li>外网服务器</li>
  <li>已备案域名</li>
  <li>想要在本地调试开放平台回调等</li>
  <li>感到ngrok官方自带的不够用</li>
</ul>

<h2 id="使用ngrok需要如何配置">使用ngrok需要如何配置</h2>

<ul>
  <li>git clone 源码</li>
  <li>生成 根证书</li>
  <li>编译服务端 用生成的根证书</li>
  <li>编译客户端 用生成的根证书 选实际客户端的平台比如mac</li>
  <li>服务端配置 服务器http端口 服务器https端口 ngrok服务运行端口</li>
  <li>云服务器存在安全组记得放开ngrok的服务器端口 比如4443</li>
  <li>客户端配置 本地端口 远程服务器端口</li>
  <li>nginx配置 隐藏远程端口而使用泛域名</li>
</ul>

<p><em>此文章还在更新中</em></p>

<p>getters.js</p>

<p>/**
     * 还有优惠可叠加使用
     * 有会员卡 且 可选的都 未选中
     * 或
     * 有优惠券 且 可选的未 都选中
     */
    hasUnChosenPomotion(state, getters) {
        const { cardPromotionList, mcCoupons } = getters
        return (cardPromotionList.length &amp;&amp; cardPromotionList.all(card =&gt; card.selected === false &amp;&amp; card.canUse))
            || mcCoupons.some(coupon =&gt; coupon.selected === false &amp;&amp; coupon.canUse)
    },</p>

<p>index.vue</p>

<p>changeCardPromotion(item) {
            const { cardId, type } = item
            this.$store.commit(‘updatePointsPayFee’, 0) // 每次修改优惠前，要清除积分抵现状态</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        const param = {
            cardId,
            singleExchangeSelected: false,
            mcPromotionSelected: false,
            shouldReComputeKouBeiSelected: false,
            memberPointsSelected: true,
            cardPaySelected: true,
            cardPays: [],
            marketCenterPromotions: [],
        }

        const index = this.selectedCardPromotions.findIndex(e =&gt; e.cardId === cardId)
        if (index &gt; -1) {
            param.cardId = ''
        } else {
            // 如果之前选中的卡是 商城卡
            // FIXME: 当前 个人优惠里 是否有 商城优惠card 选中, 那么取消它
            const hasMallCardInSingle = this.selectedCardPromotions.filter(o =&gt; o.type === 121 &amp;&amp; o.multiTag === 0).length &gt; 0
            if (hasMallCardInSingle) {
                param.mallCardId = ''
            }

            // FIXME: 如果是 商圈卡 则使用 mallCardId
            if (type === 121) {
                param.cardId = ''
                param.mallCardId = cardId
            }
        }
        // TODO: [优惠复用] 这里的param需要支持多参数
        this.requestTradeBill(param)
    },
</code></pre></div></div>

<p>actions/index.js</p>

<p>/**</p>
<ul>
  <li>
    <p>选则券 TODO: [优惠复用]
 */
function toggleCoupon({
 dispatch, commit, getters,
 state,
}, id) {
 const { choseCoupon = [] } = state
 // 兼容原单选逻辑
 const chosenCouponList = typeof choseCoupon === ‘string’ ? [choseCoupon] : [].concat(choseCoupon)
 // 开关选中优惠券id
 const index = chosenCouponList.indexOf(id)
 if (index &gt;= 0) {
     chosenCouponList.splice(index)
 } else {
     chosenCouponList.push(id)
 }
 commit(‘updateCoupons’, chosenCouponList)
 const { currentSelectedPromotions } = getters
 commit(‘updateFormParams’, {
     marketCenterPromotions: currentSelectedPromotions,
     mcPromotionSelected: !!chosenCouponList.length,
 })</p>

    <p>dispatch(‘requestTradeBill’)
}</p>
  </li>
</ul>

<p>function clearPromotions({ dispatch, commit }) {
    commit(‘updateFormParams’, {
        cardId: ‘’,
        marketCenterPromotions: [],
        mcPromotionSelected: false,
        shouldReComputeKouBeiSelected: false,
        singleExchangeSelected: false,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    memberPointsSelected: true,
    cardPaySelected: true,
    cardPays: [],
})
commit('updateCoupons', [])
dispatch('requestTradeBill') }
</code></pre></div></div>

<p>// 此为旧的改优惠券方法 不支持优惠复用
    changeCoupon,
    // 支持多选的改优惠券方法
    toggleCoupon,</p>

<p>getters.js</p>

<p>currentSelectedPromotions(state, getters) {
        const {
            choseCoupon,
            // choseExchanges
        } = state
        const {
            mcCoupons,
            // mcExchanges,
        } = getters</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // 优惠复用后choseCoupon数组
    const selectedCoupon = mcCoupons.filter(coupon =&gt; choseCoupon.indexOf(coupon.promotionCustomerId) &gt; -1) || []
    // 对组合优惠的特殊处理, 将其转化成服务端需要的数据格式
    if (!isObjectEmpty(selectedCoupon)) {
        const { promotionCustomerId, sign } = selectedCoupon
        if (promotionCustomerId === sign) {
            selectedCoupon.promotionCustomerId = ''
            selectedCoupon.promotionId = ''
            delete selectedCoupon.canUse
            delete selectedCoupon.selected
        }
    }
    // const selectedExchanges = choseExchanges.map(id =&gt;
    //     mcExchanges.filter(exchange =&gt; exchange.promotionCustomerId === id)[0])

    // return [].concat(selectedCoupon, selectedExchanges)
    return [].concat(selectedCoupon)
},
</code></pre></div></div>

<p>index.vue</p>

<p>changeCoupon(value) {
            // TODO: [优惠复用] 这里的value应该是卡ID 需要支持多参数
            this.$store.dispatch(‘changeCoupon’, value)
        },</p>

<p>promotionSummary() {
            // TODO: [优惠复用] 如果只有一项已选优惠 则显示这条 否则显示优惠组合
            if (!this.promotionParam || !this.promotionParam.selectedPromotions) {
                return ‘’
            }
            if (this.promotionParam.selectedPromotions.length === 1) {
                return <code class="highlighter-rouge">${this.promotionParam.selectedPromotions[0].cardName}: ${this.divide100(this.promotionParam.selectedPromotions[0].value)}元</code>
            }
            let rs = 0
            this.promotionParam.selectedPromotions.forEach((e) =&gt; {
                rs += e.value
            })
            return <code class="highlighter-rouge">优惠组合(优惠${this.divide100(rs)}元)</code>
        },
        hasUnChosenPomotion() {
            // TODO: [优惠复用] 根据优惠字段判断是否还有未选中的优惠(可用的)
            return ‘还有优惠可叠加使用’
        },</p>

<div class="tip">
            您已选中<span class="red"></span>项优惠，共可抵扣
            <span class="red">
                
                
            </span>
        </div>

<p>&lt;FButton class=”submit” block round @click=”togglePromotionsLayer”&gt;确认&lt;/FButton&gt;</p>

<p>// TODO: 改成由接口返回
        promotionSum() {
            let rs = 0
            this.selectedCardPromotions.forEach((e) =&gt; {
                rs += e.value
            })
            return this.divide100(rs)
        },</p>

<p>.tip {
        line-height: 2;
        background: #ec313d33;
        font-size: 12px;
        .red {
            color: red;
        }
    }</p>

<p>getters.js
    const getRealUnit = (menu) =&gt; {
            const {
                doubleUnits,
                accountUnit,
                unit = ‘’, // unit === undefined 情况下最终显示会变成 XNaN (Number + undefined -&gt; NaN)
                num,
                accountNum,
                …otherProps
            } = menu
            const menuUnit = num + unit
            const menuAccountUnit = accountNum + accountUnit
            if (doubleUnits) {
                return { …otherProps, menuUnit: <code class="highlighter-rouge">${menuUnit} (${menuAccountUnit})</code> }
            }
            return { …otherProps, menuUnit }
        }</p>


        </section>
        <section class="yitiblog-pager">
            
                <a class="block prev" href="/javascript/2019/05/04/es-module.html">
                    <img class="prev" src="/assets/images/prev.svg" alt="prev post" />
                    JavaScript模块化编程整理
                </a>
            
            
        </section>
        <footer class="yitiblog-footer">
            <div style="color: #cccccc;text-align: center;">yitimo的个人博客@2019</div>
        </footer>
    </div>
    <script>
    // baidu统计
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?decb433e7fc3d68b16da80cdd59ee827";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
    })();
    // baidu 站长
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
    <!-- <h1 style="display: none;">自己搭建ngrok服务器代理本地服务 | yitimo的个人博客</h1>
    <div class="home-body">
        <div id="blog-nav"></div>
        <div class="home-content">
            <div class="article">
                <h1>自己搭建ngrok服务器代理本地服务</h1>
                <h2 id="ngrok做了什么">ngrok做了什么</h2>

<p>正常的网络拓扑下，一般通过 <code class="highlighter-rouge">255.255.255.0</code> 掩码区分不同网段，即IP的前三段都相同视为同一网段，若想要让两个网段通信，则需要通过路由器来完成，通过在路由器中配置路由表，使两个不同网段的IP建立映射关系。</p>

<p>一般我们请求某个服务器地址时，显然本地局域网地址和远程服务器地址不在同一网段，我们是本地通过连接到本地网关，然后连接至互联网，然后连接至远程服务器。</p>

<p>但是反过来就不行了，想象一下远程服务器该如何请求到一个本地的局域网地址？</p>

<p>答案是NAT技术。</p>

<p>个人版的NAT技术的粗暴理解：类比一下本地请求远程时，客户端是如何接收到远程服务器响应的。对于远程服务器来说，其实只知道有另一个外网地址请求了自己，并给了他响应，这个外网地址即本地网关的外网地址，再由本地网关将这个来自服务器的响应精准的返回给本地地址。即本地网关把一个来自外网服务器的响应转发给了一个本地地址。</p>

<p>所以有哪些简单的方法可以做到：在本地运行一个站点，请求一个外网地址访问到这个站点？</p>

<ol>
  <li>直接给本地分配一个外网IP</li>
  <li>通过一个连接至外网的路由器进行NAT</li>
  <li>通过ngrok</li>
</ol>

<p>ngrok的内部做法和NAT不一样(目测其建立了一个C/S连接来实时监听并转发请求，而NAT只需一张映射表被动的转发请求)，但做的事情类似，远程服务器请求的是我们拥有外网地址的网关(运行了ngrok server的个人服务器)，然后由 ngrock server 来映射至建立好连接的本地 ngrok client，并根据 ngrok client 配置好的规则转发至特定端口。总结：整个ngrok(包括运行在本地的client)都属于负责转发请求的网关，这整个过程成为内网穿透。</p>

<h2 id="ngrok能做什么">ngrok能做什么</h2>

<ul>
  <li>本地调试微信授权</li>
  <li>本地调试 github hook</li>
  <li>任何需要接收外网回调的调试场景</li>
</ul>

<h2 id="使用ngrok需要自己准备什么">使用ngrok需要自己准备什么</h2>

<ul>
  <li>外网服务器</li>
  <li>已备案域名</li>
  <li>想要在本地调试开放平台回调等</li>
  <li>感到ngrok官方自带的不够用</li>
</ul>

<h2 id="使用ngrok需要如何配置">使用ngrok需要如何配置</h2>

<ul>
  <li>git clone 源码</li>
  <li>生成 根证书</li>
  <li>编译服务端 用生成的根证书</li>
  <li>编译客户端 用生成的根证书 选实际客户端的平台比如mac</li>
  <li>服务端配置 服务器http端口 服务器https端口 ngrok服务运行端口</li>
  <li>云服务器存在安全组记得放开ngrok的服务器端口 比如4443</li>
  <li>客户端配置 本地端口 远程服务器端口</li>
  <li>nginx配置 隐藏远程端口而使用泛域名</li>
</ul>

<p><em>此文章还在更新中</em></p>

<p>getters.js</p>

<p>/**
     * 还有优惠可叠加使用
     * 有会员卡 且 可选的都 未选中
     * 或
     * 有优惠券 且 可选的未 都选中
     */
    hasUnChosenPomotion(state, getters) {
        const { cardPromotionList, mcCoupons } = getters
        return (cardPromotionList.length &amp;&amp; cardPromotionList.all(card =&gt; card.selected === false &amp;&amp; card.canUse))
            || mcCoupons.some(coupon =&gt; coupon.selected === false &amp;&amp; coupon.canUse)
    },</p>

<p>index.vue</p>

<p>changeCardPromotion(item) {
            const { cardId, type } = item
            this.$store.commit(‘updatePointsPayFee’, 0) // 每次修改优惠前，要清除积分抵现状态</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        const param = {
            cardId,
            singleExchangeSelected: false,
            mcPromotionSelected: false,
            shouldReComputeKouBeiSelected: false,
            memberPointsSelected: true,
            cardPaySelected: true,
            cardPays: [],
            marketCenterPromotions: [],
        }

        const index = this.selectedCardPromotions.findIndex(e =&gt; e.cardId === cardId)
        if (index &gt; -1) {
            param.cardId = ''
        } else {
            // 如果之前选中的卡是 商城卡
            // FIXME: 当前 个人优惠里 是否有 商城优惠card 选中, 那么取消它
            const hasMallCardInSingle = this.selectedCardPromotions.filter(o =&gt; o.type === 121 &amp;&amp; o.multiTag === 0).length &gt; 0
            if (hasMallCardInSingle) {
                param.mallCardId = ''
            }

            // FIXME: 如果是 商圈卡 则使用 mallCardId
            if (type === 121) {
                param.cardId = ''
                param.mallCardId = cardId
            }
        }
        // TODO: [优惠复用] 这里的param需要支持多参数
        this.requestTradeBill(param)
    },
</code></pre></div></div>

<p>actions/index.js</p>

<p>/**</p>
<ul>
  <li>
    <p>选则券 TODO: [优惠复用]
 */
function toggleCoupon({
 dispatch, commit, getters,
 state,
}, id) {
 const { choseCoupon = [] } = state
 // 兼容原单选逻辑
 const chosenCouponList = typeof choseCoupon === ‘string’ ? [choseCoupon] : [].concat(choseCoupon)
 // 开关选中优惠券id
 const index = chosenCouponList.indexOf(id)
 if (index &gt;= 0) {
     chosenCouponList.splice(index)
 } else {
     chosenCouponList.push(id)
 }
 commit(‘updateCoupons’, chosenCouponList)
 const { currentSelectedPromotions } = getters
 commit(‘updateFormParams’, {
     marketCenterPromotions: currentSelectedPromotions,
     mcPromotionSelected: !!chosenCouponList.length,
 })</p>

    <p>dispatch(‘requestTradeBill’)
}</p>
  </li>
</ul>

<p>function clearPromotions({ dispatch, commit }) {
    commit(‘updateFormParams’, {
        cardId: ‘’,
        marketCenterPromotions: [],
        mcPromotionSelected: false,
        shouldReComputeKouBeiSelected: false,
        singleExchangeSelected: false,</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    memberPointsSelected: true,
    cardPaySelected: true,
    cardPays: [],
})
commit('updateCoupons', [])
dispatch('requestTradeBill') }
</code></pre></div></div>

<p>// 此为旧的改优惠券方法 不支持优惠复用
    changeCoupon,
    // 支持多选的改优惠券方法
    toggleCoupon,</p>

<p>getters.js</p>

<p>currentSelectedPromotions(state, getters) {
        const {
            choseCoupon,
            // choseExchanges
        } = state
        const {
            mcCoupons,
            // mcExchanges,
        } = getters</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    // 优惠复用后choseCoupon数组
    const selectedCoupon = mcCoupons.filter(coupon =&gt; choseCoupon.indexOf(coupon.promotionCustomerId) &gt; -1) || []
    // 对组合优惠的特殊处理, 将其转化成服务端需要的数据格式
    if (!isObjectEmpty(selectedCoupon)) {
        const { promotionCustomerId, sign } = selectedCoupon
        if (promotionCustomerId === sign) {
            selectedCoupon.promotionCustomerId = ''
            selectedCoupon.promotionId = ''
            delete selectedCoupon.canUse
            delete selectedCoupon.selected
        }
    }
    // const selectedExchanges = choseExchanges.map(id =&gt;
    //     mcExchanges.filter(exchange =&gt; exchange.promotionCustomerId === id)[0])

    // return [].concat(selectedCoupon, selectedExchanges)
    return [].concat(selectedCoupon)
},
</code></pre></div></div>

<p>index.vue</p>

<p>changeCoupon(value) {
            // TODO: [优惠复用] 这里的value应该是卡ID 需要支持多参数
            this.$store.dispatch(‘changeCoupon’, value)
        },</p>

<p>promotionSummary() {
            // TODO: [优惠复用] 如果只有一项已选优惠 则显示这条 否则显示优惠组合
            if (!this.promotionParam || !this.promotionParam.selectedPromotions) {
                return ‘’
            }
            if (this.promotionParam.selectedPromotions.length === 1) {
                return <code class="highlighter-rouge">${this.promotionParam.selectedPromotions[0].cardName}: ${this.divide100(this.promotionParam.selectedPromotions[0].value)}元</code>
            }
            let rs = 0
            this.promotionParam.selectedPromotions.forEach((e) =&gt; {
                rs += e.value
            })
            return <code class="highlighter-rouge">优惠组合(优惠${this.divide100(rs)}元)</code>
        },
        hasUnChosenPomotion() {
            // TODO: [优惠复用] 根据优惠字段判断是否还有未选中的优惠(可用的)
            return ‘还有优惠可叠加使用’
        },</p>

<div class="tip">
            您已选中<span class="red"></span>项优惠，共可抵扣
            <span class="red">
                
                
            </span>
        </div>

<p>&lt;FButton class=”submit” block round @click=”togglePromotionsLayer”&gt;确认&lt;/FButton&gt;</p>

<p>// TODO: 改成由接口返回
        promotionSum() {
            let rs = 0
            this.selectedCardPromotions.forEach((e) =&gt; {
                rs += e.value
            })
            return this.divide100(rs)
        },</p>

<p>.tip {
        line-height: 2;
        background: #ec313d33;
        font-size: 12px;
        .red {
            color: red;
        }
    }</p>

<p>getters.js
    const getRealUnit = (menu) =&gt; {
            const {
                doubleUnits,
                accountUnit,
                unit = ‘’, // unit === undefined 情况下最终显示会变成 XNaN (Number + undefined -&gt; NaN)
                num,
                accountNum,
                …otherProps
            } = menu
            const menuUnit = num + unit
            const menuAccountUnit = accountNum + accountUnit
            if (doubleUnits) {
                return { …otherProps, menuUnit: <code class="highlighter-rouge">${menuUnit} (${menuAccountUnit})</code> }
            }
            return { …otherProps, menuUnit }
        }</p>


            </div>
            <div class="article-pager">
                
                <a class="article-pager-block" href="/javascript/2019/05/04/es-module.html">
                    <img src="/assets/images/prev.svg" alt="Older" />
                    <span class="article-pager-block-title">JavaScript模块化编程整理</span>
                    <span class="article-pager-block-tag">更新的</span>
                </a>
                
                
            </div>
        </div>
        <div style="color: #cccccc;text-align: center;">yitimo的个人博客@2019</div>
        <script>
    // baidu统计
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?decb433e7fc3d68b16da80cdd59ee827";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
    })();
    // baidu 站长
    (function(){
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        }
        else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>
    </div> -->
</body>
</html>
